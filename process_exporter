#!/usr/bin/perl

use strict;
use warnings;

use Getopt::Long;
use IO::Async::Signal;
use IO::Async::Loop;
use Net::Async::HTTP::Server::PSGI;
use Net::Prometheus 0.05;
use POSIX qw( strftime );
use YAML;

sub printlog
{
   print strftime( "[%Y-%m-%d %H:%M:%S] ", localtime ), @_, "\n";
}

GetOptions(
   'C|config-file=s' => \( my $CONFIG_FILE = "process_exporter.yaml" ),
   'p|port=i'        => \( my $PORT = 9124 ),
) or exit 1;

my $CONFIG = YAML::LoadFile( $CONFIG_FILE );

my $loop = IO::Async::Loop->new;

my $prometheus = Net::Prometheus->new;

my %collectors_by_name;
reapply_config();

$loop->add( IO::Async::Signal->new(
   name => "HUP",
   on_receipt => sub {
      printlog "Reloading config due to SIGHUP";

      eval { $CONFIG = YAML::LoadFile( $CONFIG_FILE ); 1 } or do {
         printlog "Unable to load config - $@";
         return;
      };

      reapply_config();
   }
) );

my $server = Net::Async::HTTP::Server::PSGI->new(
   app => $prometheus->psgi_app
);
$loop->add( $server );

$server->listen(
   socktype => "stream",
   service  => $PORT,
)->get;

printlog "Listening for metrics on http://[::0]:" . $server->read_handle->sockport;

$loop->run;

sub reapply_config
{
   # First create new watchers
   my $processes = $CONFIG->{processes};

   foreach my $name ( keys %$processes ) {
      next if $collectors_by_name{$name};

      my $config = $processes->{$name};
      my $collector = ProcessCollector->new(
         name    => $name,
         pidfile => $config->{pidfile},
         pid     => $config->{pid},
      );

      printlog "Now watching $name(" . ( $collector->pid // "??" ). ")";
      $prometheus->register( $collectors_by_name{$name} = $collector );
   }

   # TODO: now reconfigure existing ones

   foreach my $name ( keys %collectors_by_name ) {
      next if $processes->{$name};

      printlog "No longer watching $name";
      $prometheus->unregister( delete $collectors_by_name{$name} );
   }
}

package ProcessCollector;

sub new
{
   my $class = shift;
   my %args = @_;

   return bless {
      name    => $args{name},
      pidfile => $args{pidfile},
      pid     => $args{pid},
   }, $class;
}

sub pid
{
   my $self = shift;
   defined( my $pidfile = $self->{pidfile} ) or
      return $self->{pid};

   # TODO: cache
   open my $fh, "<", $pidfile or return undef;

   my $pid = <$fh>; chomp $pid;

   # Check if the PID is valid
   -e "/proc/$pid" or return undef;

   return $self->{pid} = $pid;
}

sub collect
{
   my $self = shift;

   my $pid = $self->pid;

   if( defined $pid and defined $self->{last_pid} and $pid != $self->{last_pid} ) {
      ::printlog "Process $self->{name} changed its pid to $pid";

      undef $self->{collector};
      $self->{last_pid} = $pid;
   }

   return unless defined $pid;

   my $collector = $self->{collector} //=
      Net::Prometheus::ProcessCollector->new(
         pid    => $pid,
         prefix => "exported_process",
         labels => [ exported_job => $self->{name} ],
      );

   my @metrics = $collector->collect;

   return $collector->_make_metric( up => @metrics ? 1 : 0,
      "gauge", "The value 1 if the exported process exists" ),
      @metrics;
}
